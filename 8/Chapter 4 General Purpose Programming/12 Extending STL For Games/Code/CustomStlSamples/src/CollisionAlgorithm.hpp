//---------------------------------------------------------------------------
// Copyright (c) 2009, Neil Gower
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without 
// modification, are permitted provided that the following conditions are 
// met:
//
//   * Redistributions of source code must retain the above copyright 
//     notice, this list of conditions and the following disclaimer.
//
//   * Redistributions in binary form must reproduce the above copyright 
//     notice, this list of conditions and the following disclaimer in the 
//     documentation and/or other materials provided with the distribution.
//
//   * Neither the name of Vertex Blast nor the names of its contributors 
//     may be used to endorse or promote products derived from this software
//     without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
// OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//---------------------------------------------------------------------------
#ifndef GPG8_COLLISION_ALGORITHM_HPP
#define GPG8_COLLISION_ALGORITHM_HPP 1

#include <algorithm>

//---------------------------------------------------------------------------
/// This is a generic collision algorithm. It tests all of the objects in the
/// input range for collisions with each other, using the 
/// CollisionTestFunctor. The list of possible colliders for a given
/// collidee is generated by the CandidatesFunctor. By making this functor
/// more selective, the overall efficiency of this function can be greatly 
/// improved.
///
/// srcBegin      - The start of the input range.
/// srcEnd        - The end of the input range.
/// destBegin     - The start of an output range, i.e. an iterator into a 
///                 container for the results.
/// getCandidates - The CandidatesFunctor to use for generating candidate
///                 colliders for a particular object. When invoked, the
///                 functor is passed the object, and is expected to return a
///                 pair of iterators over a range of possibly colliding 
///                 objects
/// testCollision - The CollisionTestFunctor to use for testing for actual
///                 collisions between pairs of objects. When invoked, the
///                 functor is passed to objects, and is expected to return
///                 a bool indicating whether or not they are intersecting.
//---------------------------------------------------------------------------
template <typename SrcIterator, 
          typename DestIterator,
          typename CandidatesFunctor, 
          typename CollisionTestFunctor>
void generate_collisions( SrcIterator srcBegin, 
                          SrcIterator srcEnd,
                          DestIterator destBegin,
                          CandidatesFunctor getCandidates,
                          CollisionTestFunctor testCollision ) {
    // some typedefs to help readability
    typedef typename SrcIterator::value_type CollisionObject;
    typedef typename CandidatesFunctor::ResultsIterator ResultsIterator;
    
    // keep track of how many candidates we actually had to test, as an
    // measure of efficiency.
    int numCandidatesChecked = 0;

    // for each collidee in the src list, get the list of possible colliders
    typename CandidatesFunctor::Results candidates;
    for ( SrcIterator i = srcBegin; i != srcEnd; ++i ) {
        CollisionObject& collidee = *i;
        candidates = getCandidates( collidee );

        // check for collisions between the collidee and candidate colliders
        for ( ResultsIterator j = candidates.first;
              j != candidates.second;
              ++j ) {
            ++numCandidatesChecked;
            CollisionObject& collider = *j;
            if ( collidee != collider 
                    // this lets us avoid re-testing previously visited 
                    // pairs, as long as collider and collidee come from the
                    // same container (so they have consistent addresses).
                    && &collidee < &collider
                    && testCollision(collidee, collider) ) {
                // collision detected!
                *destBegin++ = std::make_pair(&collidee, &collider);
            }
        }
    }
}

#endif
