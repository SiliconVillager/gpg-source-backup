<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>AioServerSample: Socket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Socket Class Reference</h1><!-- doxytag: class="Socket" -->
<p><a class="el" href="class_socket.html" title="Socket is a wrapper class for the platform&#39;s socket API, which also provides...">Socket</a> is a wrapper class for the platform's socket API, which also provides some higher-level functionality like managing partial sends and receives.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Socket.h&gt;</code></p>

<p><a href="class_socket-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_socket.html">Socket</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#afa77dd6b25c416a98bd9fd463cd25f9b">SocketPtr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef-ed so that this could be upgraded to a smart pointer class in the future.  <a href="#afa77dd6b25c416a98bd9fd463cd25f9b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#a7c3256c4fc6e2c603df73201049fae5a">Socket</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an unconnected socket instance.  <a href="#a7c3256c4fc6e2c603df73201049fae5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#aeac4eb6379a543d38ed88977d3b6630a">~Socket</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cleanup includes disconnection, if this has not already been done with the <a class="el" href="class_socket.html#a75ee749264ccbcfc4dfbf5442e55dcb8" title="Terminates the connection, possibly blocking until any outstanding asynchronous I/O...">close()</a> function.  <a href="#aeac4eb6379a543d38ed88977d3b6630a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#a61d9b1abee329c87f289f6c4afa1e12b">connect</a> (const std::string &amp;host, const std::string &amp;port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initiates a connection to the remote host on the given port.  <a href="#a61d9b1abee329c87f289f6c4afa1e12b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#afe4cee9e1131007dd1db23bdfbf744b8">listen</a> (const std::string &amp;port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Binds this socket to a particular port on the local end, suitable for accepting incoming client connections.  <a href="#afe4cee9e1131007dd1db23bdfbf744b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_socket.html">SocketPtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#a6bac54dc07d05dbdd624492183651c9e">accept</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Blocks until an incoming client connection is made.  <a href="#a6bac54dc07d05dbdd624492183651c9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#a75ee749264ccbcfc4dfbf5442e55dcb8">close</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Terminates the connection, possibly blocking until any outstanding asynchronous I/O operations are completed or cancelled.  <a href="#a75ee749264ccbcfc4dfbf5442e55dcb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#a0484ab63a86b492a7e458c93c66d7352">write</a> (void *pData, size_t numBytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempts to send numBytes of the data pointed to by pData using synchronous non-blocking I/O.  <a href="#a0484ab63a86b492a7e458c93c66d7352"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#a1c9650da7bd619af0809a179d54ffb5f">asyncWrite</a> (void *pData, size_t numBytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempts to send numBytes of the data in pData using asynchronous I/O.  <a href="#a1c9650da7bd619af0809a179d54ffb5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#a618ceab8ce57653b2acf75ff368c4645">isWriting</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true is there is currently an asynchronous write operation in progress, or an incomplete synchronous write.  <a href="#a618ceab8ce57653b2acf75ff368c4645"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#ac96160486032a729e991cfbaa469ee8a">read</a> (void *pData, size_t numBytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempts to receive numBytes using synchronous non-blocking I/O.  <a href="#ac96160486032a729e991cfbaa469ee8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#a77d64b6ce4ec73f5537aa0a07919dd45">asyncRead</a> (void *pData, size_t numBytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempts to receive numBytes using asynchronous I/O.  <a href="#a77d64b6ce4ec73f5537aa0a07919dd45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#a60c76a4c1e26192218d598b63cbb97b9">isConnected</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this socket is currently connected to the remote socket, false otherwise.  <a href="#a60c76a4c1e26192218d598b63cbb97b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#a43012c8a63f3dce04b3e8620e9057a0b">isListening</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this socket is listening for new client connections, i.e.  <a href="#a43012c8a63f3dce04b3e8620e9057a0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#ab29e434f6c009b95d53a56b45d5a4b2a">getBytesRead</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total number of bytes that have been successfully received by this socket since it was created.  <a href="#ab29e434f6c009b95d53a56b45d5a4b2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#a06b557eec651094ad7b00c2adfa0cdc2">getBytesSent</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total number of bytes that have been successfully sent over this socket since it was created.  <a href="#a06b557eec651094ad7b00c2adfa0cdc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#a5501d16bca2388568b976de2b50cebf5">getRawHandle</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a hack that exposes the underlying file descriptor or handle for the connection.  <a href="#a5501d16bca2388568b976de2b50cebf5"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#a94596438fb6b20dbb20bd622e46fbb58">reportStats</a> (double workingTime)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dumps global stats about socket performance to stdout, given the total amount of CPU time measured by the application that was related to I/O.  <a href="#a94596438fb6b20dbb20bd622e46fbb58"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#abec59ddb06958b46cc2db267602d7947">MAX_WRITE_SIZE</a> = 32 * 1024</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#a7bda541660da5ca5f8732ad1639f698c">MAX_READ_SIZE</a> = 8 * 1024</td></tr>
<tr><td colspan="2"><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#a7ee6d3631b8c3583a25b2ffcc4d5b206">Socket</a> (<a class="el" href="class_socket_impl.html">SocketImpl</a> *pSocketImpl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This constructor is used internally to create new client sockets in <a class="el" href="class_socket.html#a6bac54dc07d05dbdd624492183651c9e" title="Blocks until an incoming client connection is made.">accept()</a>.  <a href="#a7ee6d3631b8c3583a25b2ffcc4d5b206"></a><br/></td></tr>
<tr><td colspan="2"><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_socket_impl.html">SocketImpl</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#ad7629affb7267a33383aedb388d104d8">m_pImpl</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the <a class="el" href="class_socket_impl.html" title="This is the Winsock2 version of SocketImpl.">SocketImpl</a>, which contains all of the real functionality.  <a href="#ad7629affb7267a33383aedb388d104d8"></a><br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_socket.html#a021f4d98d65fdedb1987546c0a6a75e2">SocketImpl</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Some aspects of the implementation can be streamlined by having access to the internals of the <a class="el" href="class_socket_impl.html" title="This is the Winsock2 version of SocketImpl.">SocketImpl</a>.  <a href="#a021f4d98d65fdedb1987546c0a6a75e2"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_socket.html" title="Socket is a wrapper class for the platform&#39;s socket API, which also provides...">Socket</a> is a wrapper class for the platform's socket API, which also provides some higher-level functionality like managing partial sends and receives. </p>
<p>This class provides access to both asynchronous and non-blocking synchronous send and receive functions. Although you may be able to switch back and forth between these methods on a single socket, the intended usage is really to use one method or the other for the lifetime of the <a class="el" href="class_socket.html" title="Socket is a wrapper class for the platform&#39;s socket API, which also provides...">Socket</a> object. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="afa77dd6b25c416a98bd9fd463cd25f9b"></a><!-- doxytag: member="Socket::SocketPtr" ref="afa77dd6b25c416a98bd9fd463cd25f9b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_socket.html">Socket</a>* <a class="el" href="class_socket.html">Socket::SocketPtr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Typedef-ed so that this could be upgraded to a smart pointer class in the future. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7c3256c4fc6e2c603df73201049fae5a"></a><!-- doxytag: member="Socket::Socket" ref="a7c3256c4fc6e2c603df73201049fae5a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Socket::Socket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an unconnected socket instance. </p>

</div>
</div>
<a class="anchor" id="aeac4eb6379a543d38ed88977d3b6630a"></a><!-- doxytag: member="Socket::~Socket" ref="aeac4eb6379a543d38ed88977d3b6630a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Socket::~Socket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cleanup includes disconnection, if this has not already been done with the <a class="el" href="class_socket.html#a75ee749264ccbcfc4dfbf5442e55dcb8" title="Terminates the connection, possibly blocking until any outstanding asynchronous I/O...">close()</a> function. </p>

</div>
</div>
<a class="anchor" id="a7ee6d3631b8c3583a25b2ffcc4d5b206"></a><!-- doxytag: member="Socket::Socket" ref="a7ee6d3631b8c3583a25b2ffcc4d5b206" args="(SocketImpl *pSocketImpl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Socket::Socket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_socket_impl.html">SocketImpl</a> *&nbsp;</td>
          <td class="paramname"> <em>pSocketImpl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This constructor is used internally to create new client sockets in <a class="el" href="class_socket.html#a6bac54dc07d05dbdd624492183651c9e" title="Blocks until an incoming client connection is made.">accept()</a>. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a61d9b1abee329c87f289f6c4afa1e12b"></a><!-- doxytag: member="Socket::connect" ref="a61d9b1abee329c87f289f6c4afa1e12b" args="(const std::string &amp;host, const std::string &amp;port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Socket::connect </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initiates a connection to the remote host on the given port. </p>

</div>
</div>
<a class="anchor" id="afe4cee9e1131007dd1db23bdfbf744b8"></a><!-- doxytag: member="Socket::listen" ref="afe4cee9e1131007dd1db23bdfbf744b8" args="(const std::string &amp;port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Socket::listen </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>port</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Binds this socket to a particular port on the local end, suitable for accepting incoming client connections. </p>

</div>
</div>
<a class="anchor" id="a6bac54dc07d05dbdd624492183651c9e"></a><!-- doxytag: member="Socket::accept" ref="a6bac54dc07d05dbdd624492183651c9e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_socket.html">Socket::SocketPtr</a> Socket::accept </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Blocks until an incoming client connection is made. </p>
<p>Returns a new socket instance for the client connection. It is the caller's responsibility to delete the socket when they are done with it, since we're not using smart pointers. </p>

</div>
</div>
<a class="anchor" id="a75ee749264ccbcfc4dfbf5442e55dcb8"></a><!-- doxytag: member="Socket::close" ref="a75ee749264ccbcfc4dfbf5442e55dcb8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::close </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Terminates the connection, possibly blocking until any outstanding asynchronous I/O operations are completed or cancelled. </p>

</div>
</div>
<a class="anchor" id="a0484ab63a86b492a7e458c93c66d7352"></a><!-- doxytag: member="Socket::write" ref="a0484ab63a86b492a7e458c93c66d7352" args="(void *pData, size_t numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Socket::write </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempts to send numBytes of the data pointed to by pData using synchronous non-blocking I/O. </p>
<p>Returns the total number of bytes transferred, which may be less than numBytes in the case of a partial write or if the socket would block. In these cases calling <a class="el" href="class_socket.html#a0484ab63a86b492a7e458c93c66d7352" title="Attempts to send numBytes of the data pointed to by pData using synchronous non-blocking...">write()</a> again with pData = NULL will attempt to send the rest of the data. Calling <a class="el" href="class_socket.html#a0484ab63a86b492a7e458c93c66d7352" title="Attempts to send numBytes of the data pointed to by pData using synchronous non-blocking...">write()</a> again with pData != NULL will be a no-op and is recorded as a "push-back", i.e. the caller is trying to send new data before the old data could be completely sent.</p>
<p>Since this prototype code, it will assert() on any unexpected socket errors. </p>

</div>
</div>
<a class="anchor" id="a1c9650da7bd619af0809a179d54ffb5f"></a><!-- doxytag: member="Socket::asyncWrite" ref="a1c9650da7bd619af0809a179d54ffb5f" args="(void *pData, size_t numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::asyncWrite </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempts to send numBytes of the data in pData using asynchronous I/O. </p>
<p>This could be made more efficient by checking m_bWriteInProgress to early out, but arguably that gives an unfair advantage to the async implementation.</p>
<p>On partial write, the underlying <a class="el" href="class_socket_impl.html" title="This is the Winsock2 version of SocketImpl.">SocketImpl</a> will automatically initiate additional write operations to complete the transfer. Calling <a class="el" href="class_socket.html#a1c9650da7bd619af0809a179d54ffb5f" title="Attempts to send numBytes of the data in pData using asynchronous I/O.">asyncWrite()</a> while another write operation is still in progress will be a no-op, and is recorded as a push-back (see docs for synchronous <a class="el" href="class_socket.html#a0484ab63a86b492a7e458c93c66d7352" title="Attempts to send numBytes of the data pointed to by pData using synchronous non-blocking...">write()</a> for details about push-backs).</p>
<p>Since this prototype code, it will assert() on any unexpected socket errors.</p>

</div>
</div>
<a class="anchor" id="a618ceab8ce57653b2acf75ff368c4645"></a><!-- doxytag: member="Socket::isWriting" ref="a618ceab8ce57653b2acf75ff368c4645" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Socket::isWriting </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true is there is currently an asynchronous write operation in progress, or an incomplete synchronous write. </p>

</div>
</div>
<a class="anchor" id="ac96160486032a729e991cfbaa469ee8a"></a><!-- doxytag: member="Socket::read" ref="ac96160486032a729e991cfbaa469ee8a" args="(void *pData, size_t numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Socket::read </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempts to receive numBytes using synchronous non-blocking I/O. </p>
<p>If less than numBytes are received, the read request remains active, and future calls will resume receiving the remaining data. Returns the total number of bytes received so far for the currently active request.</p>
<p>Since the model server doesn't actually use the data after it is received, all transfers use an internal buffer in the <a class="el" href="class_socket_impl.html" title="This is the Winsock2 version of SocketImpl.">SocketImpl</a>. A complete implementation would of course receive into pData.</p>
<p>Since this prototype code, it will assert() on any unexpected socket errors. </p>

</div>
</div>
<a class="anchor" id="a77d64b6ce4ec73f5537aa0a07919dd45"></a><!-- doxytag: member="Socket::asyncRead" ref="a77d64b6ce4ec73f5537aa0a07919dd45" args="(void *pData, size_t numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::asyncRead </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempts to receive numBytes using asynchronous I/O. </p>
<p>See note in <a class="el" href="class_socket.html#a1c9650da7bd619af0809a179d54ffb5f" title="Attempts to send numBytes of the data in pData using asynchronous I/O.">asyncWrite()</a> about early out, which also applies here with m_bReadInProgress.</p>
<p>As in the synchronous <a class="el" href="class_socket.html#ac96160486032a729e991cfbaa469ee8a" title="Attempts to receive numBytes using synchronous non-blocking I/O.">read()</a> function, the data is transferred into an internal buffer, since the model server doesn't actually use the data after it arrives. In the case of partial reads, the <a class="el" href="class_socket_impl.html" title="This is the Winsock2 version of SocketImpl.">SocketImpl</a> will initiate additional asynchronous read requests until the full numBytes of data is received. Calls to <a class="el" href="class_socket.html#a77d64b6ce4ec73f5537aa0a07919dd45" title="Attempts to receive numBytes using asynchronous I/O.">asyncRead()</a> while a read operation is active are no-ops.</p>
<p>Since this prototype code, it will assert() on any unexpected socket errors.</p>

</div>
</div>
<a class="anchor" id="a60c76a4c1e26192218d598b63cbb97b9"></a><!-- doxytag: member="Socket::isConnected" ref="a60c76a4c1e26192218d598b63cbb97b9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Socket::isConnected </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this socket is currently connected to the remote socket, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a43012c8a63f3dce04b3e8620e9057a0b"></a><!-- doxytag: member="Socket::isListening" ref="a43012c8a63f3dce04b3e8620e9057a0b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Socket::isListening </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this socket is listening for new client connections, i.e. </p>
<p>if <a class="el" href="class_socket.html#a6bac54dc07d05dbdd624492183651c9e" title="Blocks until an incoming client connection is made.">accept()</a> can be called successfully. Otherwise, returns false. </p>

</div>
</div>
<a class="anchor" id="a94596438fb6b20dbb20bd622e46fbb58"></a><!-- doxytag: member="Socket::reportStats" ref="a94596438fb6b20dbb20bd622e46fbb58" args="(double workingTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Socket::reportStats </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>workingTime</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dumps global stats about socket performance to stdout, given the total amount of CPU time measured by the application that was related to I/O. </p>

</div>
</div>
<a class="anchor" id="ab29e434f6c009b95d53a56b45d5a4b2a"></a><!-- doxytag: member="Socket::getBytesRead" ref="ab29e434f6c009b95d53a56b45d5a4b2a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Socket::getBytesRead </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the total number of bytes that have been successfully received by this socket since it was created. </p>

</div>
</div>
<a class="anchor" id="a06b557eec651094ad7b00c2adfa0cdc2"></a><!-- doxytag: member="Socket::getBytesSent" ref="a06b557eec651094ad7b00c2adfa0cdc2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Socket::getBytesSent </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the total number of bytes that have been successfully sent over this socket since it was created. </p>

</div>
</div>
<a class="anchor" id="a5501d16bca2388568b976de2b50cebf5"></a><!-- doxytag: member="Socket::getRawHandle" ref="a5501d16bca2388568b976de2b50cebf5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Socket::getRawHandle </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is a hack that exposes the underlying file descriptor or handle for the connection. </p>
<p>Use with caution. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a021f4d98d65fdedb1987546c0a6a75e2"></a><!-- doxytag: member="Socket::SocketImpl" ref="a021f4d98d65fdedb1987546c0a6a75e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_socket_impl.html">SocketImpl</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Some aspects of the implementation can be streamlined by having access to the internals of the <a class="el" href="class_socket_impl.html" title="This is the Winsock2 version of SocketImpl.">SocketImpl</a>. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="abec59ddb06958b46cc2db267602d7947"></a><!-- doxytag: member="Socket::MAX_WRITE_SIZE" ref="abec59ddb06958b46cc2db267602d7947" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="class_socket.html#abec59ddb06958b46cc2db267602d7947">Socket::MAX_WRITE_SIZE</a> = 32 * 1024<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7bda541660da5ca5f8732ad1639f698c"></a><!-- doxytag: member="Socket::MAX_READ_SIZE" ref="a7bda541660da5ca5f8732ad1639f698c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="class_socket.html#a7bda541660da5ca5f8732ad1639f698c">Socket::MAX_READ_SIZE</a> = 8 * 1024<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad7629affb7267a33383aedb388d104d8"></a><!-- doxytag: member="Socket::m_pImpl" ref="ad7629affb7267a33383aedb388d104d8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_socket_impl.html">SocketImpl</a>* <a class="el" href="class_socket.html#ad7629affb7267a33383aedb388d104d8">Socket::m_pImpl</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pointer to the <a class="el" href="class_socket_impl.html" title="This is the Winsock2 version of SocketImpl.">SocketImpl</a>, which contains all of the real functionality. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_socket_8h.html">Socket.h</a></li>
<li><a class="el" href="_socket_8cpp.html">Socket.cpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Sep 27 17:32:28 2009 for AioServerSample by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
